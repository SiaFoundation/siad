package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"math"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"text/tabwriter"
	"time"

	"go.sia.tech/core/chain"
	"go.sia.tech/core/types"
	"go.sia.tech/siad/v2/api/siad"
	"go.sia.tech/siad/v2/internal/chainutil"
	"go.sia.tech/siad/v2/internal/cpuminer"
	"go.sia.tech/siad/v2/wallet"
	"golang.org/x/term"

	"lukechampine.com/flagg"
	"lukechampine.com/frand"
)

var (
	// to be supplied at build time
	githash   = "?"
	builddate = "?"
)

var (
	rootUsage = `Usage:
    siac [flags] [action|subcommand]

Actions:
    version         display version information
    mine            mine one or more blocks
    seed            generate a wallet seed

Subcommands:
    wallet
    txpool
    syncer
`
	versionUsage = rootUsage

	walletUsage = `Usage:
    siac [flags] wallet [flags] [action]

Actions:
    address         generate a wallet address
    addresses       list wallet addresses
    balance         view current balance
    transactions    list wallet-related transactions
    send            send siacoin
    sign            sign a transaction
`

	walletBalanceUsage = `Usage:
    siac [flags] wallet [flags] balance

View the current wallet balance.
`
	walletAddressUsage = `Usage:
    siac [flags] wallet [flags] address

Generate a new wallet address.
`
	walletAddressesUsage = `Usage:
    siac [flags] wallet [flags] addresses

List addresses generated by the wallet.
`

	walletTransactionsUsage = `Usage:
    siac [flags] wallet [flags] transactions

List transactions relevant to the wallet.
`

	walletSignUsage = `Usage:
    siac [flags] wallet [flags] sign [file]

Signs all wallet-controlled inputs of the provided JSON-encoded transaction.
The result is written to a new file.
`

	walletSendUsage = `Usage:
    siac [flags] wallet [flags] send [outputs]

Construct, sign, and broadcast a transaction with the specified outputs,
which are provided as a comma-separated list of address:value pairs, e.g.

	export DEST_ADDR=a1b2c3...d4e5f6
    siac wallet send $DEST_ADDR:78.9SC,$DEST_ADDR:2SF
`

	txpoolUsage = `Usage:
    siac [flags] txpool [flags] [action]

Actions:
    transactions    display all transactions in the transaction pool
    broadcast       broadcast a JSON-encoded transaction
`

	txpoolBroadcastUsage = `Usage:
    siac [flags] txpool [flags] broadcast [file]

Broadcast a JSON-encoded transaction.
`

	txpoolTransactionsUsage = `Usage:
    siac [flags] txpool [flags] transactions

List transactions in the transaction pool.
`

	syncerUsage = `Usage:
    siac [flags] syncer [flags] [action]

Actions:
    peers           display all the syncer's peers
    connect         add a peer to the syncer
`

	syncerPeersUsage = `Usage:
    siac [flags] syncer [flags] peers

List current peers.
`

	syncerConnectUsage = `Usage:
    siac [flags] syncer [flags] connect [addr]

Add the provided address as a peer.
`

	seedUsage = `Usage:
    siac [flags] seed [flags]

Generate a new seed
`

	mineUsage = `Usage:
    siac [flags] mine [flags]

Mines blocks using the CPU until killed.
`
)

func check(ctx string, err error) {
	if err != nil {
		log.Fatalln(ctx, err)
	}
}

var siadAddr string
var siadClient *siad.Client

func getClient() *siad.Client {
	if siadClient != nil {
		return siadClient
	}
	password := getAPIPassword()
	if !strings.HasPrefix(siadAddr, "https://") && !strings.HasPrefix(siadAddr, "http://") {
		siadAddr = "http://" + siadAddr
	}
	c := siad.NewClient(siadAddr+"/api", password)
	_, err := c.ConsensusTip()
	check("Couldn't connect to siad:", err)
	siadClient = c
	return c
}

func makeTabWriter() *tabwriter.Writer {
	return tabwriter.NewWriter(
		os.Stdout,
		0,   // minwidth: zero, since we're left-aligning
		0,   // tabwidth: zero, since we're using ' ',  not '\t'
		2,   // padding:  two, so that columns aren't right next to each other
		' ', // padchar:  spaces, not tabs
		0,   // flags:    none
	)
}

func getAPIPassword() string {
	apiPassword := os.Getenv("SIAD_API_PASSWORD")
	if len(apiPassword) == 0 {
		fmt.Print("Enter API password: ")
		pw, err := term.ReadPassword(int(os.Stdin.Fd()))
		fmt.Println()
		if err != nil {
			log.Fatal(err)
		}
		apiPassword = string(pw)
	} else {
		fmt.Println("Using SIAD_API_PASSWORD environment variable.")
	}
	return apiPassword
}

func getSeed() wallet.Seed {
	fmt.Print("Seed: ")
	pw, err := term.ReadPassword(int(os.Stdin.Fd()))
	fmt.Println()
	if err != nil {
		log.Fatal(err)
	}
	seed, err := wallet.SeedFromString(string(pw))
	if err != nil {
		log.Fatal(err)
	}
	return seed
}

func main() {
	log.SetFlags(0)
	var verbose, exactCurrency, broadcast bool
	var minerLimit int
	var desc, minerAddr string

	rootCmd := flagg.Root
	rootCmd.Usage = flagg.SimpleUsage(rootCmd, rootUsage)
	rootCmd.StringVar(&siadAddr, "a", "localhost:9980", "siad API server address")
	rootCmd.BoolVar(&verbose, "v", false, "print verbose output")

	versionCmd := flagg.New("version", versionUsage)

	walletCmd := flagg.New("wallet", walletUsage)
	walletBalanceCmd := flagg.New("balance", walletBalanceUsage)
	walletBalanceCmd.BoolVar(&exactCurrency, "exact", false, "print balance in Hastings")
	walletAddressCmd := flagg.New("address", walletAddressUsage)
	walletAddressCmd.StringVar(&desc, "desc", "", "description for the new address")
	walletAddressesCmd := flagg.New("addresses", walletAddressesUsage)
	walletTransactionsCmd := flagg.New("transactions", walletTransactionsUsage)
	walletSignCmd := flagg.New("sign", walletSignUsage)
	walletSignCmd.BoolVar(&broadcast, "broadcast", false, "immediately broadcast the transaction")
	walletSendCmd := flagg.New("send", walletSendUsage)

	txpoolCmd := flagg.New("txpool", txpoolUsage)
	txpoolBroadcastCmd := flagg.New("broadcast", txpoolBroadcastUsage)
	txpoolTransactionsCmd := flagg.New("transactions", txpoolTransactionsUsage)

	syncerCmd := flagg.New("syncer", syncerUsage)
	syncerPeersCmd := flagg.New("peers", syncerPeersUsage)
	syncerConnectCmd := flagg.New("connect", syncerConnectUsage)

	seedCmd := flagg.New("seed", seedUsage)
	mineCmd := flagg.New("mine", mineUsage)
	mineCmd.StringVar(&minerAddr, "addr", "", "address that will receive block rewards")
	mineCmd.IntVar(&minerLimit, "limit", 0, "number of blocks to mine")

	cmd := flagg.Parse(flagg.Tree{
		Cmd: rootCmd,
		Sub: []flagg.Tree{
			{Cmd: versionCmd},
			{
				Cmd: walletCmd,
				Sub: []flagg.Tree{
					{Cmd: walletAddressCmd},
					{Cmd: walletAddressesCmd},
					{Cmd: walletBalanceCmd},
					{Cmd: walletTransactionsCmd},
					{Cmd: walletSignCmd},
					{Cmd: walletSendCmd},
				},
			},
			{
				Cmd: txpoolCmd,
				Sub: []flagg.Tree{
					{Cmd: txpoolTransactionsCmd},
					{Cmd: txpoolBroadcastCmd},
				},
			},
			{
				Cmd: syncerCmd,
				Sub: []flagg.Tree{
					{Cmd: syncerPeersCmd},
					{Cmd: syncerConnectCmd},
				},
			},
			{Cmd: seedCmd},
			{Cmd: mineCmd},
		},
	})
	args := cmd.Args()

	switch cmd {
	case rootCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}
		fallthrough
	case versionCmd:
		log.Printf("siac v2.0.0\nCommit:     %s\nGo version: %s %s/%s\nBuild Date: %s\n",
			githash, runtime.Version(), runtime.GOOS, runtime.GOARCH, builddate)

	case walletCmd:
		cmd.Usage()

	case walletAddressCmd:
		if len(args) > 1 {
			cmd.Usage()
			return
		}
		index, err := getClient().WalletSeedIndex()
		check("Couldn't get current seed index:", err)
		addr := types.StandardAddress(getSeed().PublicKey(index))
		err = getClient().WalletAddAddress(addr, wallet.AddressInfo{
			Index:       index,
			Description: desc,
		})
		check("Couldn't add address:", err)
		fmt.Println(addr)

	case walletAddressesCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}
		addresses, err := getClient().WalletAddresses(0, math.MaxInt64)
		check("Couldn't get address:", err)
		for _, address := range addresses {
			fmt.Println(address)
		}

	case walletBalanceCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}
		balance, err := getClient().WalletBalance()
		check("Couldn't get balance:", err)
		if exactCurrency {
			fmt.Printf("%d H\n", balance.Siacoins)
		} else {
			fmt.Printf("%s\n", balance.Siacoins)
		}
		fmt.Printf("%d SF\n", balance.Siafunds)

	case walletTransactionsCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}
		txns, err := getClient().WalletTransactions(time.Time{}, -1)
		check("Couldn't get transactions:", err)

		w := makeTabWriter()
		defer w.Flush()
		fmt.Fprintf(w, "%v\t%v\t%v\t%v\n", "ID", "In (SC)", "Out (SC)", "Time")
		for _, txn := range txns {
			fmt.Fprintf(w, "%v\t%v\t%v\t%v\n", txn.ID, txn.Inflow, txn.Outflow, txn.Timestamp)
		}

	case walletSignCmd:
		if len(args) != 1 {
			cmd.Usage()
			return
		}

		txn := readTxn(args[0])
		err := signTxn(&txn, getSeed())
		check("failed to sign transaction:", err)
		if broadcast {
			err = getClient().TxpoolBroadcast(txn, nil)
			check("failed to broadcast transaction:", err)
			fmt.Println("Signed and broadcast transaction.")
		} else {
			ext := filepath.Ext(args[0])
			signedPath := strings.TrimSuffix(args[0], ext) + "-signed" + ext
			writeTxn(signedPath, txn)
			fmt.Printf("Wrote signed transaction to %v.\n", signedPath)
		}

	case walletSendCmd:
		if len(args) != 1 {
			cmd.Usage()
			return
		}

		// parse outputs
		var txn types.Transaction
		for _, p := range strings.Split(args[0], ",") {
			addrAmount := strings.Split(p, ":")
			if len(addrAmount) != 2 {
				check("Could not parse outputs", errors.New("outputs must be specified in addr:amount pairs"))
			}
			addr, err := types.ParseAddress(strings.TrimSpace(addrAmount[0]))
			check("Invalid destination address", err)
			if strings.HasSuffix(addrAmount[1], "SF") {
				amount, err := strconv.ParseUint(strings.TrimSuffix(addrAmount[1], "SF"), 10, 64)
				check("Invalid currency amount", err)
				txn.SiafundOutputs = append(txn.SiafundOutputs, types.SiafundOutput{Address: addr, Value: amount})
			} else {
				amount, err := types.ParseCurrency(addrAmount[1])
				check("Invalid currency amount", err)
				txn.SiacoinOutputs = append(txn.SiacoinOutputs, types.SiacoinOutput{Address: addr, Value: amount})
			}
		}

		seed := getSeed()
		err := fundTxn(&txn, seed)
		check("Could not fund transaction", err)
		err = signTxn(&txn, seed)
		check("Could not sign transaction", err)
		err = broadcastTxn(txn)
		check("Could not broadcast transaction", err)
		fmt.Println("Transaction broadcast successfully.")
		fmt.Println("Transaction ID:", txn.ID())

	case txpoolCmd:
		cmd.Usage()

	case txpoolBroadcastCmd:
		if len(args) != 1 {
			cmd.Usage()
			return
		}

		txn := readTxn(args[0])
		err := getClient().TxpoolBroadcast(txn, nil)
		check("failed to broadcast transaction:", err)
		fmt.Println("Broadcast transaction.")

	case txpoolTransactionsCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}

		transactions, err := getClient().TxpoolTransactions()
		check("Couldn't get transactions:", err)

		w := makeTabWriter()
		defer w.Flush()
		fmt.Fprintf(w, "%v\n", "ID")
		for _, txn := range transactions {
			fmt.Fprintf(w, "%v\n", txn.ID())
		}

	case syncerCmd:
		cmd.Usage()

	case syncerPeersCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}
		peers, err := getClient().SyncerPeers()
		check("Couldn't get peers:", err)

		w := makeTabWriter()
		defer w.Flush()
		fmt.Fprintf(w, "%v\n", "NetAddress")
		for _, peer := range peers {
			fmt.Fprintf(w, "%v\n", peer.NetAddress)
		}

	case syncerConnectCmd:
		if len(args) != 1 {
			cmd.Usage()
			return
		}
		addr := args[0]
		err := getClient().SyncerConnect(addr)
		check("Couldn't connect:", err)
		fmt.Printf("Connected to %v.\n", addr)

	case seedCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}
		fmt.Println(wallet.NewSeed())

	case mineCmd:
		addr, err := types.ParseAddress(minerAddr)
		if minerAddr != "" {
			check("Invalid address", err)
		}
		start := time.Now()
		if minerLimit != 0 {
			for i := 0; i < minerLimit; i++ {
				fmt.Printf("\rMining...(%d/%d, %.2f/sec)", i, minerLimit, float64(i)/time.Since(start).Seconds())
				mineBlock(addr)
			}
			fmt.Println("")
		} else {
			for i := 0; ; i++ {
				fmt.Printf("\rMining...(%d/∞, %.2f/sec)", i, float64(i)/time.Since(start).Seconds())
				mineBlock(addr)
			}
		}
	}
}

func readTxn(filename string) types.Transaction {
	js, err := os.ReadFile(filename)
	check("Could not read transaction file", err)
	var txn types.Transaction
	err = json.Unmarshal(js, &txn)
	check("Could not parse transaction file", err)
	return txn
}

func writeTxn(filename string, txn types.Transaction) {
	js, _ := json.MarshalIndent(txn, "", "  ")
	js = append(js, '\n')
	err := os.WriteFile(filename, js, 0666)
	check("Could not write transaction to disk", err)
}

func fundTxn(txn *types.Transaction, seed wallet.Seed) error {
	var amount types.Currency
	for _, sco := range txn.SiacoinOutputs {
		amount = amount.Add(sco.Value)
	}
	amount = amount.Add(txn.MinerFee)
	for _, sci := range txn.SiacoinInputs {
		amount = amount.Sub(sci.Parent.Value)
	}

	if amount.IsZero() {
		return nil
	}

	tip, err := getClient().ConsensusTip()
	if err != nil {
		return err
	}
	pool, err := getClient().TxpoolTransactions()
	if err != nil {
		return err
	}
	utxos, err := getClient().WalletUTXOs()
	if err != nil {
		return err
	}

	// avoid reusing any inputs currently in the transaction pool
	inPool := make(map[types.ElementID]bool)
	for _, ptxn := range pool {
		for _, in := range ptxn.SiacoinInputs {
			inPool[in.Parent.ID] = true
		}
	}

	var outputSum types.Currency
	var fundingElements []types.SiacoinElement
	for _, sce := range utxos.Siacoins {
		if inPool[sce.ID] || tip.Height < sce.MaturityHeight {
			continue
		}
		fundingElements = append(fundingElements, sce)
		outputSum = outputSum.Add(sce.Value)
		if outputSum.Cmp(amount) >= 0 {
			break
		}
	}
	if outputSum.Cmp(amount) < 0 {
		return errors.New("insufficient balance")
	} else if outputSum.Cmp(amount) > 0 {
		index, err := getClient().WalletSeedIndex()
		if err != nil {
			return err
		}
		// generate a change address
		info := wallet.AddressInfo{
			Index:       index,
			Description: "change addr for " + txn.ID().String(),
		}
		addr := types.StandardAddress(seed.PublicKey(info.Index))
		err = getClient().WalletAddAddress(addr, info)
		if err != nil {
			return err
		}
		txn.SiacoinOutputs = append(txn.SiacoinOutputs, types.SiacoinOutput{
			Value:   outputSum.Sub(amount),
			Address: addr,
		})
	}

	for _, sce := range fundingElements {
		info, err := getClient().WalletAddressInfo(sce.Address)
		if err != nil {
			return err
		}
		txn.SiacoinInputs = append(txn.SiacoinInputs, types.SiacoinInput{
			Parent:      sce,
			SpendPolicy: types.PolicyPublicKey(seed.PublicKey(info.Index)),
		})
	}
	return nil
}

func signTxn(txn *types.Transaction, seed wallet.Seed) error {
	cs, err := getClient().ConsensusTipState()
	if err != nil {
		return err
	}
	sigHash := cs.InputSigHash(*txn)
	for i := range txn.SiacoinInputs {
		if info, err := getClient().WalletAddressInfo(txn.SiacoinInputs[i].Parent.Address); err == nil {
			txn.SiacoinInputs[i].Signatures = []types.Signature{seed.PrivateKey(info.Index).SignHash(sigHash)}
		}
	}
	return nil
}

func broadcastTxn(txn types.Transaction) error {
	return getClient().TxpoolBroadcast(txn, nil)
}

func mineBlock(addr types.Address) {
again:
	cs, err := getClient().ConsensusTipState()
	check("Could not get tip state", err)
	txns, err := getClient().TxpoolTransactions()
	check("Could not get txpool", err)
	txns = cpuminer.TransactionsForBlock(cs, txns)

	parent := cs.Index
	b := types.Block{
		Header: types.BlockHeader{
			Height:       parent.Height + 1,
			ParentID:     parent.ID,
			Nonce:        frand.Uint64n(math.MaxUint64),
			Timestamp:    types.CurrentTimestamp(),
			Commitment:   cs.Commitment(addr, txns),
			MinerAddress: addr,
		},
		Transactions: txns,
	}
	chainutil.FindBlockNonce(cs, &b.Header, types.HashRequiringWork(cs.Difficulty))

	err = getClient().ConsensusBroadcast(b)
	if err != nil {
		if !strings.Contains(err.Error(), chain.ErrUnknownIndex.Error()) {
			check("Could not submit block", err)
		}
		goto again
	}
}
